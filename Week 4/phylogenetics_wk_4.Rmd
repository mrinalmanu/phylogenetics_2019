---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

```{r}
# imports
# BiocManager::install('ips')
library(seqinr)
library(phangorn)
library(ape)
library(ips)

```

```{r}
#############################################
# Build UPGMA and NJ trees for this alignment
#############################################

seq <- read.alignment('/home/mrinalmanu/Documents/3_sem_hws/Phylogenetics homeworks 2019/Week 4/input/SUP35_aln.best.fas', format = 'fasta')
aln <- dist.alignment(seq, matrix = 'identity')

```


```{r}
upg <- upgma(aln)

#pdf("/home/mrinalmanu/Documents/3_sem_hws/Phylogenetics homeworks 2019/Week 4/output/UPGMAtree.pdf")
plot(upg)
#dev.off()

```

```{r}

nj_tree <- nj(aln)

#pdf("/home/mrinalmanu/Documents/3_sem_hws/Phylogenetics homeworks 2019/Week 4/output/NJtree.pdf")

plot(nj_tree)
#dev.off()

```


```{r}

#fasta to Phylip conversion code
fastaobject<-seqinr::read.fasta("//home/mrinalmanu/Documents/3_sem_hws/Phylogenetics homeworks 2019/Week 4/input/SUP35_aln.best.fas")
ape::write.dna(fastaobject, "//home/mrinalmanu/Documents/3_sem_hws/Phylogenetics homeworks 2019/Week 4/output/phyfile.phy", nbcol=1,colsep="", colw=1000000)

```

```{r}
#############################################
# Rooting the trees
#############################################
rooting_upgma <- root(upg, outgroup = c('SUP35_Kla_AB039749', "SUP35_Agos_ATCC_10895_NM_211584"))
plot(rooting_upgma)
```

```{r}
rooting_nj <- root(nj_tree, outgroup = c('SUP35_Kla_AB039749', "SUP35_Agos_ATCC_10895_NM_211584"))

plot(rooting_nj)
```

The phylogenetic tree represents an approximation of how related sequences are, sometimes many slightly different trees could represent the similarities between your sequences.

The Neighbour Joining tree building algorithm is a really clever way of very quickly converting a distance matrix into a phylogeny. A lot of other algorithms exist, depending on your data, some are more appropriate than others.

Maximum Likelihood, is a different means of generating, potentially a more accurate, phylogenetic tree. This algorithm creates and compares lots of slightly different phylogenetic trees and selects which one best represents your data.

Once you've got a tree, bootstrapping can be used to provide estimates of how confident you can be in its structure.

Source: https://josephcrispell.github.io/BlogPosts/Phylogeny_20-02-18/Phylogeny_20-02-18.html

```{r}
#############################################
# Model selection
#############################################
# First install jmodeltest2 from here:
# https://github.com/ddarriba/jmodeltest2
# Read in the FASTA file
sequencesDNAbin <- read.dna("/home/mrinalmanu/Documents/3_sem_hws/Phylogenetics homeworks 2019/Week 4/input/SUP35_aln.best.fas", format = "fasta", skip=1)
# Convert the sequences from a DNAbin format into a PhyDat format
sequencesPhyDat <- phyDat(sequencesDNAbin, type = "DNA", levels = NULL)

# Compute likelihood of the initial Neighbour Joining tree given sequences
likelihoodObject_upg <- phangorn::pml(upg, sequencesPhyDat)

# Set the controls for the Maximum Likelihood algorithm
controls_upg <- pml.control(maxit=100000, trace=0)

# Run maximum likelihood
fittingOutput_upg <- optim.pml(likelihoodObject_upg,
  optNni = TRUE, # Optimise topology
  optInv = TRUE, # Optimise proportion of variable sites
  model = "JC", # Substitution model
  rearrangement="NNI", # Nearest Neighbour Interchanges
  control=controls_upg)

# Get the Maximum Likelihood tree
mlTree_upg <- fittingOutput_upg$tree

mlTree_upg

```

```{r,  echo=FALSE, results='hide'}
# Bootstrap the result of maximum likelihood
bootstrapResults_upg <- bootstrap.pml(
  fittingOutput_upg, # Use Maximium Likelihood settings on bootstrapped sequences
  bs = 100, # Number times to bootstrap sequences
  optNni = TRUE, # Use Nearest Neighbour Interchanges in tree building
  jumble=TRUE) # Jumble bootstrapped sequences before building trees

# Get phylogenetic tree with bootstrap values
# Returns phylogenetic tree with bootstrap values as node labels
treeBS_upg <- plotBS(
  fittingOutput_upg$tree,
  bootstrapResults_upg,
  p = 50, # Plot bootstrap values if node in >=50 bootstrap trees
  type="phylogram") # Type of phylogenetic tree shape to plot


```

##### Repeating steps for neighbour joining tree.
```{r}

# Compute likelihood of the initial Neighbour Joining tree given sequences
likelihoodObject <- pml(nj_tree, sequencesPhyDat)

# Set the controls for the Maximum Likelihood algorithm
controls <- pml.control(maxit=100000, trace=0)

# Run maximum likelihood
fittingOutput <- optim.pml(likelihoodObject,
  optNni = TRUE, # Optimise topology
  optInv = TRUE, # Optimise proportion of variable sites
  model = "JC", # Substitution model
  rearrangement="NNI", # Nearest Neighbour Interchanges
  control=controls)

# Get the Maximum Likelihood tree
mlTree <- fittingOutput$tree


```

```{r,  echo=FALSE, results='hide'}
# Bootstrap the result of maximum likelihood
bootstrapResults <- bootstrap.pml(
  fittingOutput, # Use Maximium Likelihood settings on bootstrapped sequences
  bs = 100, # Number times to bootstrap sequences
  optNni = TRUE, # Use Nearest Neighbour Interchanges in tree building
  jumble=TRUE) # Jumble bootstrapped sequences before building trees

# Get phylogenetic tree with bootstrap values
# Returns phylogenetic tree with bootstrap values as node labels
treeBS <- plotBS(
  fittingOutput$tree,
  bootstrapResults,
  p = 50, # Plot bootstrap values if node in >=50 bootstrap trees
  type="phylogram") # Type of phylogenetic tree shape to plot

```
```{r}
#############################################
# Partition Finder (Optional part)
#############################################

# Download partitionfinder from here:
# https://codeload.github.com/brettc/partitionfinder/zip/master

# upg_pf <- partitionfinder(aln, upg, branchlengths = "linked",
#   models = "all", model.selection = "BIC", search = "greedy",
#   exec = "/home/mrinalmanu/partitionfinder-master/PartitionFinder.py")

# I will redo this step again later. Multiple problems with package dependencies.
```